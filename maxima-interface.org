#+TITLE: Interfacing to Maxima from Common Lisp
#+STARTUP: showall

* Introduction

** The Maxima manual has some information on the interface between Common Lisp and Maxima. While this document describes how to jump back and forth from Maxima to the CL REPL (using to_lisp() and (to-maxima)), it does not offer much help in the way of actually creating code that interoperates.

** A bird's eye view of what Maxima does can be found in the diagram file maxima/doc/implementation/maximatoplevelflow.ps

* Installation and loading.

** Create a symbolic link from maxima/src to $HOME/quicklisp/local-projects.

** Load the maxima package with:

#+BEGIN_SRC common-lisp
(ql:quickload "maxima")
(in-package :maxima)
#+END_SRC

* Evaluating Maxima commands from CL

** We can rely on Maxima's parser. For example:

#+BEGIN_SRC common-lisp
MAXIMA> (with-input-from-string (stream "expand((a + b)^2);") (dbm-read stream nil))
((DISPLAYINPUT) NIL (($EXPAND) ((MEXPT) ((MPLUS) $A $B) 2)))
#+END_SRC

** Additionally, we could write more directly:

#+BEGIN_SRC common-lisp
MAXIMA> (meval '(($EXPAND) ((MEXPT) ((MPLUS) $A $B) 2)))
((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((MTIMES SIMP) 2 $A $B) ((MEXPT SIMP) $B 2))
#+END_SRC

** Then we could display the result using:

#+BEGIN_SRC common-lisp
MAXIMA> (displa (meval '(($expand) ((mexpt) ((mplus) $a $b) 2))))
 2            2
b  + 2 a b + a
NIL
#+END_SRC

* From Robert Dodier's [[https://maxima.sourceforge.io/docs/tutorial/en/minimal-maxima.pdf][Minimal Maxima]]:

** General

- Maxima is a collection of functions to transform
one expression into another

- an expression is a list of the form ((op) x1 x2 x3 ...)

- an expression is indistinguishable from an
unevaluated function call
e.g. {a, b, c} is (($set) a b c) internally,
indistinguishable from set(a, b, c)

- almost every Maxima object is an expression

- vague but important distinction between
simplification (1+1 => 2, sin(0) => 0) and evaluation

- an unbound atom evaluates to itself

- one namespace holds all system and user names

- there are two kinds of Maxima functions:
programming functions (these have function definitions)
and mathematical functions (also called simplifying
functions; behavior results from simplification rules)

- there are three kinds of Maxima programming functions:
argument-evaluating, defined in Lisp (defmfun),
argument-quoting, defined in Lisp (defmspec),
argument-evaluating, defined in Maxima (define or :=)

- for many functions, side effects (files, global
variables) are important

- almost all logic is embedded in the code
(few operations are driven by rules or tables)

- Maxima is extensible to varying degrees

- new programming function: easy

- new operator like + * ! [] etc:
defining the operator programming function is easy;
simplification rules are possible, not easy

- new mathematical function: possible, not easy

- new object (e.g. set): essentially same as
a new mathematical function

- changing behavior of existing element:
usually requires Lisp hacking (only for brave and/or foolish)

Maxima programming language

- procedural language reminiscent of Algol

- some elements reminiscent of Lisp (block, apply, map)

- dynamically scoped

- not implemented: closures, structures with named
attributes, and namespaces

Maxima and Lisp

- Lisp name $foo equivalent to Maxima name foo,
Lisp name foo equivlent to Maxima name ?foo

- typically user-visible function named $foo farms out
subcases to internal functions foo-case1, foo-case2, etc

- default mode is to interpret Maxima input,
but Maxima input can be translated into Lisp,
or translated and compiled

- Maxima core is written entirely in Lisp (not Maxima)

- add-on functions written in Maxima or Lisp

File organization

- core implementation in maxima/src

- add-on functions in maxima/share/*
(one directory per package)

- regression tests in maxima/tests

- documentation in maxima/doc
